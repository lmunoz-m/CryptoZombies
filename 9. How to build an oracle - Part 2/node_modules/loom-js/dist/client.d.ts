/// <reference types="node" />
import { Message } from 'google-protobuf';
import EventEmitter from 'events';
import retry from 'retry';
import { VMType, EvmTxReceipt } from './proto/loom_pb';
import { Address } from './address';
/**
 * Middleware handlers are expected to transform the input data and return the result.
 * Handlers should not modify the original input data in any way.
 */
export interface ITxMiddlewareHandler {
    Handle(txData: Readonly<Uint8Array>): Promise<Uint8Array>;
}
export declare enum ClientEvent {
    /**
     * Emitted when an event is received from a smart contract.
     * Listener will receive IChainEventArgs.
     */
    Contract = "contractEvent",
    /**
     * Emitted when an error occurs that can't be relayed by other means.
     * Listener will receive IClientErrorEventArgs.
     */
    Error = "error",
    /**
     * Emitted when a connection is established to the DAppChain.
     * Listener will receive INetEventArgs.
     */
    Connected = "connected",
    /**
     * Emitted when a connection with the DAppChain is closed.
     * Listener will receive INetEventArgs.
     */
    Disconnected = "disconnected",
}
export interface IClientEventArgs {
    kind: ClientEvent;
    /** URL that corresponds to the RPC client this event originated from. */
    url: string;
}
/**
 * Event that's emitted when some kind of error occurs that can't be relayed by other means,
 * e.g. socket error that occurs while listening for RPC events.
 */
export interface IClientErrorEventArgs extends IClientEventArgs {
    kind: ClientEvent.Error;
    /** May contain additional information in case of an RPC error. */
    error?: any;
}
/** Generic event containing data emitted by smart contracts. */
export interface IChainEventArgs extends IClientEventArgs {
    kind: ClientEvent.Contract;
    /** Address of the contract that emitted the event. */
    contractAddress: Address;
    /** Address of the caller that caused the event to be emitted. */
    callerAddress: Address;
    /** The block containing the tx that caused this event to be emitted. */
    blockHeight: string;
    /**
     * Data that was actually emitted by the smart contract,
     * the format and structure is defined by that contract.
     */
    data: Uint8Array;
}
export declare function isInvalidTxNonceError(err: any): boolean;
/**
 * Writes to & reads from a Loom DAppChain.
 *
 * The client can listen to events emitted by smart contracts running on a DAppChain,
 * there is currently only one type of event. The event subscription API matches the NodeJS
 * EventEmitter API. For example...
 *
 * function subscribeToEvents(client: Client) {
 *   client.on(ClientEvent.Contract, (event: IChainEventArgs) => {
 *     // handle event
 *   }
 * }
 */
export declare class Client extends EventEmitter {
    readonly chainId: string;
    private _writeClient;
    private _readClient;
    /** Middleware to apply to transactions before they are transmitted to the DAppChain. */
    txMiddleware: ITxMiddlewareHandler[];
    /**
     * The retry strategy that should be used to resend a tx when it's rejected because of a bad nonce.
     * Default is a binary exponential retry strategy with 5 retries.
     * To understand how to tweak the retry strategy see
     * https://github.com/tim-kos/node-retry#retrytimeoutsoptions
     */
    nonceRetryStrategy: retry.OperationOptions;
    readonly readUrl: string;
    readonly writeUrl: string;
    /**
     * Constructs a new client to read & write data from/to a Loom DAppChain.
     * @param chainId DAppChain identifier.
     * @param writeUrl Host & port to send txs, specified as "<protocol>://<host>:<port>".
     * @param readUrl Host & port of the DAppChain read/query interface, this should only be provided
     *                if it's not the same as `writeUrl`.
     */
    constructor(chainId: string, writeUrl: string, readUrl?: string);
    /**
     * Cleans up all underlying network resources.
     * Once disconnected the client can no longer be used to interact with the DAppChain.
     */
    disconnect(): void;
    /**
     * Commits a transaction to the DAppChain.
     *
     * Consider using Contract.callAsync() instead.
     *
     * @param tx Transaction to commit.
     * @param opts Options object.
     * @param opts.middleware Middleware to apply before sending the tx to the DAppChain, setting this
     *                        option will override the default set of middleware specified in
     *                        the `Client.txMiddleware` property.
     * @returns Result (if any) returned by the tx handler in the contract that processed the tx.
     */
    commitTxAsync<T extends Message>(tx: T, opts?: {
        middleware?: ITxMiddlewareHandler[];
    }): Promise<Uint8Array | void>;
    private _commitTxAsync<T>(tx, middleware);
    /**
     * Queries the current state of a contract.
     *
     * Consider using Contract.staticCallAsync() instead.
     */
    queryAsync(contract: Address, query?: Uint8Array, vmType?: VMType, caller?: Address): Promise<Uint8Array | void>;
    /**
     * Queries the receipt corresponding to a transaction hash
     *
     * @param txHash Transaction hash returned by call transaction.
     * @return EvmTxReceipt The corresponding transaction receipt.
     */
    getTxReceiptAsync(txHash: Uint8Array): Promise<EvmTxReceipt | null>;
    /**
     * Queries the code corresponding to a contract
     *
     * @param contractAddress Contract address returned by deploy.
     * @return Uint8Array The corresponding contract code
     */
    getCodeAsync(contractAddress: Address): Promise<Uint8Array | null>;
    /**
     * Gets a nonce for the given public key.
     *
     * This should only be called by NonceTxMiddleware.
     *
     * @param key A hex encoded public key.
     * @return The nonce.
     */
    getNonceAsync(key: string): Promise<number>;
    /**
     * Tries to resolve a contract name to an address.
     *
     * @param contractName Name of a smart contract on a Loom DAppChain.
     * @returns Contract address, or null if a contract matching the given name wasn't found.
     */
    getContractAddressAsync(contractName: string): Promise<Address | null>;
    private _emitContractEvent(url, event);
    private _emitNetEvent(url, kind, error?);
}
